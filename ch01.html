<html><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r"><title>Глава 1. Краткий учебник про sed.</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="index.html" title="Краткий учебник по sed."><link rel="prev" href="index.html" title="Краткий учебник по sed."><link rel="next" href="ch01s02.html" title="Использование sed."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Глава 1. Краткий учебник про sed.</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch01s02.html">След.</a></td></tr></table><hr></div><div class="chapter" title="Глава 1. Краткий учебник про sed."><div class="titlepage"><div><div><h2 class="title"><a name="id2508519"></a>Глава 1. Краткий учебник про sed.</h2></div></div></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="section"><a href="ch01.html#id2508525">Зачем?</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#id2508532">Вступление.</a></span></dt><dt><span class="section"><a href="ch01.html#id2508596">Основные понятия.</a></span></dt><dt><span class="section"><a href="ch01.html#id2508762">История(программа ed).</a></span></dt><dt><span class="section"><a href="ch01.html#id2509167">Где применяется sed.</a></span></dt><dt><span class="section"><a href="ch01.html#id2509408">Итог.</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s02.html">Использование sed.</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s02.html#id2509694">Как работает sed?</a></span></dt><dt><span class="section"><a href="ch01s02.html#id2509961">Применение адресных выражений в sed.</a></span></dt><dt><span class="section"><a href="ch01s02.html#id2510071">sed-скрипты из нескольких команд.</a></span></dt><dt><span class="section"><a href="ch01s02.html#id2510209">Использование перевода строки для разделение команд, и создание sed-скриптов в файле.</a></span></dt><dt><span class="section"><a href="ch01s02.html#id2510387">sed и vim</a></span></dt><dt><span class="section"><a href="ch01s02.html#id2510468">Подавление вывода ключом <code class="option">-n</code></a></span></dt></dl></dd><dt><span class="section"><a href="ch01s03.html">Регулярные выражения.</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s03.html#id2510581">Что такое регулярные выражения?</a></span></dt><dt><span class="section"><a href="ch01s03.html#id2510648">Команда поиска и замены <span class="command"><strong>s</strong></span>.</a></span></dt></dl></dd></dl></div><div class="section" title="Зачем?"><div class="titlepage"><div><div><h3 class="title"><a name="id2508525"></a>Зачем?</h3></div></div></div><a name="tutorial"></a><div class="section" title="Вступление."><div class="titlepage"><div><div><h4 class="title"><a name="id2508532"></a>Вступление.</h4></div></div></div><p>
				Уж я и не знаю, зачем вы это всё читаете, зато прекрасно знаю, для кого это написано: для тех, кому понадобилось научится применять одну из многих UNIX-Way утилит - GNUsed.
			</p><p>
				Вообще говоря, sed появилась более 30 лет назад, потому споры о том, что это чисто "линуксоидная" фишка, бессмысленны: существуют версии sed для MS-DOS, Windows, MacOS, да и наверное для всех систем где понятие <span class="emphasis"><em>текст</em></span> имеет хоть какой-то смысл.
			</p><p>
				Что такое sed? Это (как вам уже наверняка известно) <span class="emphasis"><em>потоковый текстовый редактор</em></span>. Текст поступает на обработку не в виде файла как обычно, а в виде <span class="emphasis"><em>потока</em></span>.  По этой причине, sed даже более универсальна, чем все остальные редакторы. Утилита sed может работать без участия оператора, без возможности вывода текста, на системах где вывод файлов вообще не возможен, и даже там, где не существует самих файлов! Достаточно всего-лишь потоков, а уж они есть практически везде.
			</p></div><div class="section" title="Основные понятия."><div class="titlepage"><div><div><h4 class="title"><a name="id2508596"></a>Основные понятия.</h4></div></div></div><p>
				<span class="emphasis"><em>Программы должны уметь обмениваться информацией.</em></span> Это аксиома. Если программы этого не умеют, это не программы, а набор разбухших монстров, которые еле ворочаются на самых современных компьютерах. Примеры всем известны. Проблема только в том, что для обмена нужно выработать правила взаимодействия, в основном, в каком виде обмениваться? Много лет назад, ещё во времена UNIX, было решено обмениваться исключительно текстовой информацией, и появилось соглашение, что считать текстом, а что - нет. Конечно, многие программы используют какие-то особые, специальные форматы, однако, обмениваться ими в общем случае невозможно (если конечно нет подходящего конвертера спец-формат&lt;-&gt;текст). Соглашения следующие:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><span class="emphasis"><em>Текст</em></span> - это упорядоченный набор <span class="emphasis"><em>строк</em></span>. Строк может быть любое количество, в том числе их может не быть вовсе.
					</li><li class="listitem"><span class="emphasis"><em>Строка</em></span> - это упорядоченный набор <span class="emphasis"><em>символов</em></span>. Каждая строка заканчивается особым символом '\n'.
					</li><li class="listitem"><span class="emphasis"><em>Символ</em></span> - это минимальный неделимый элемент текста.
					</li><li class="listitem"><span class="emphasis"><em>Алфавитом</em></span> называется список всех допустимых символов в тексте.
					</li></ol></div><p>
				Особый случай - это "чистый текст(plain-text)", алфавит в нём состоит из байтов 32...127, 10, и 9.
			</p><p>
				Если пользователь, а тем более программист не согласен с этими соглашениями, то у него возникают проблемы.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3><p>
						Примеров - масса: я сам, помнится, расстраивался, что у меня "не работает" планировщик - я дописал к его таблице свою строчку, однако планировщик меня тупо игнорировал. Всё просто, не было никакой строчки, была фигня непонятная! Я нарушил пункт 2 - не добавил в конец строки '\n'. Хотя это скорее беда моего редактора, просил-ведь: "сохрани <span class="emphasis"><em>как текст</em></span>", а он...
						</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
							По поводу последнего предложения: Как и все юзеры, я готов обвинять что угодно, кроме собственной криворукости :-)
						</div><p>
					</p><p>
						Особо отмечу проблемы с текстами в UTF-8. В них символы могут быть в несколько байтов, но это ещё не самое страшное (нас это обычно не сильно волнует, это проблема разработчиков sed, мы можем заметить разве-что сильное уменьшение быстродействия). Самое противное - в "тексте" могут появляться <span class="emphasis"><em>несимволы</em></span>, что приводит к совершенно неожиданным результатам.
					</p></div><p>
			</p></div><div class="section" title="История(программа ed)."><div class="titlepage"><div><div><h4 class="title"><a name="id2508762"></a>История(программа ed).</h4></div></div></div><p>
				Первую свою программу я написал лет 20 назад. Однако историю я знаю ещё глубже - дело в том, что в то время (впрочем как и сейчас) новейший супер-компьютер мне никто не дал, пришлось мучиться на довольно старой технике. Именно по этому я и знаю, какими были тогда текстовые редакторы.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Кстати, они и сейчас есть: если у вас любой Linux просто наберите <span class="command"><strong>ed</strong></span>. Сразу скажу: что-бы выйти из этого чуда, надо набрать команду <span class="command"><strong>q</strong></span>, что впрочем относится ко многим утилитам, в т.ч. и к sed.
				</div><p>
			</p><p>
				Основная (для меня) прелесть Linux заключается в том, что мы можем всё сразу попробовать. Достаточно открыть второе окно (вторую консоль для некромантов), и там набирать команды. ИМХО, если у вас хорошо развита моторная память, вам лучше команды именно <span class="emphasis"><em>набирать</em></span>, тем-же, у кого более развита зрительная - можно копировать мышкой (кстати, я именно так и делаю).
				</p><div class="warning" title="Внимание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Внимание</h3>
					Деструктивных примеров здесь не будет конечно, однако, будьте осторожны: не нужно экспериментировать с правами root'а в каталоге со сверх-ценными данными. Все тестовые файлы могут быть изменены, что намного хуже, чем если-бы они были просто удалены. Посему, создайте каталог для тестов, и уж там развлекайтесь. Я вас предупредил.
				</div><p>
			</p><p>
				Раз уж зашла речь о программах, давайте напишем программу на C.
				</p><div class="example"><a name="id2508845"></a><p class="title"><b>Пример 1.1. Программа test.c.</b></p><div class="example-contents"><pre class="programlisting">
#include &lt;stdio.h&gt;

/* comment */

int main()
{
	printf("тестовый файл\n");
	return 0;
}

					</pre></div></div><p><br class="example-break">
				Что делает эта программа не столь важно (если вам интересно - то всё что она сделает будучи скомпилированной - выведет на экран фразу "тестовый файл" и завершит работу), нам интересна эта программа всего-лишь как образец текста. Попробуем отредактировать эту программу так, как это делал я более 20 лет назад:
				</p><pre class="screen">
$ed test.c
90
				</pre><p>
				программа ed написала 90 и что-то ждёт. Ну 90 - это размер файла для редактирования, а ждёт наш редактор команды... Первое что хочется сделать - просмотреть файл. Для этого существует команда <span class="command"><strong>p</strong></span>, которая выведет нужные нам строки. Какие именно? Это нужно указать явно, по умолчанию будет выведена только последняя строка, записав <span class="command"><strong>1,$p</strong></span> мы выведем все строки нашего файла. Тут 1,$ означает диапазон строк, от первой строки, и до последней (последняя строка обозначается <code class="option">$</code>). Это выражение называется <span class="emphasis"><em>адресным</em></span>, либо просто - адресом, так-как оно определяет, к каким именно строкам будет применена данная команда.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					На самом деле, адресные выражения намного более разнообразны (и в sed, и в ed), но для ed я не смог найти выражения, что-бы вывести весь текст сразу. Только через несколько минут до меня дошло, что это просто не нужно - реальные тексты состоят из тысяч строк, потому и нет таких адресов - что-бы всё и сразу. Ну выведется 10000 строк, мы их всё равно не успеем прочитать (парадокс: древние компьютеры работали намного быстрее).
				</div><p>
			</p><p>
				Теперь отредактируем наш файл, к примеру заменим "return 0;", на "return 77;". Как всегда, для этого существует множество путей, наверное самый простой, это заново набрать всю строчку. Команда замены строчек у нас есть, называется она <span class="command"><strong>c</strong></span>; однако, нужно ещё и указать, к чему-же её применить (к какой именно строке). Проще всего указать номер этой строки, но его тоже надо узнать (хотя можно и посчитать, но это не наш метод), наберём <span class="command"><strong>1,$n</strong></span>:
				</p><pre class="screen">
1       #include &lt;stdio.h&gt;
2
3       /* comment */
4
5       int main()
6       {
7               printf("тестовый файл\n");
8               return 0;
9       }
10
				</pre><p>
				Эта команда сработала так-же как <span class="command"><strong>p</strong></span>, только перед каждой строкой вывелся её номер, и теперь ясно, что нам нужно изменить восьмую строчку. Для этого наберём <span class="command"><strong>8c</strong></span>, и теперь наберём строчку по новой, нажмём ENTER и CTRL+C. Просмотрев файл, мы убедимся, что замена выполнена.
			</p><p>
				Согласитесь, неудобно. Однако, в те далёкие семидесятые годы прошлого века ничего другого придумать было нельзя, текст на экране терминала безвозвратно уползал вверх, и мы видели только последние 24 строки (в 25й вводилась команда). Навигация по тексту как в современных редакторах была невозможна, потому пришлось придумать другие методы. Впрочем тут и придумывать ничего не надо: просто нужно <span class="emphasis"><em>заменить в строке 8 число 0 на число 77</em></span>. Для этого (кто-бы мог подумать) имеется команда замены. Я долго не понимал, почему эта команда называется <span class="command"><strong>s</strong></span>, а не более логично, например <span class="command"><strong>replace</strong></span>. Точно это мне неизвестно до сих пор, но думается, что главное в этой команде вовсе не замена, а поиск (<span class="command"><strong>s</strong></span>earch), нам сначала надо <span class="emphasis"><em>найти</em></span> число 0, и уж затем, если найдём конечно, его заменить. Записывается это просто: <span class="command"><strong>8s/0/77/</strong></span>, т.е. "в восьмой строке нужно заменить 0 на 77".
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Мне подсказали, почему команда <span class="command"><strong>s</strong></span> называется именно так: от слова <span class="emphasis"><em>substitution</em></span>.
				</div><p>
			</p><p>
				Но на практике и это неудобно - проще было-бы не нам смотреть номер строки с "return", а заставить это сделать компьютер. И конечно это ещё тогда было реализовано: в качестве адреса можно задать не только номер, но и саму строку, или даже часть строки, наберём к примеру <span class="command"><strong>/ret/n</strong></span>:
				</p><pre class="screen">8               return 0;</pre><p>
				Как видите, ed самостоятельно находит строку с <code class="option">/ret/</code>, и выполняет для неё заданную команду.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Можно задавать диапазоны вроде <code class="option">/begin/,/end/</code>, для всех строк начиная со строки со словом "begin", и кончая строкой со словом "end", либо к примеру <code class="option">/start/,$</code>, что значит: от строки со словом "start" и до конца текста. Например (для нашей программы):
					<span class="command"><strong>/{/,/}/p</strong></span><pre class="screen">
{
	printf("тестовый файл\n");
	return 77;
}
					</pre>
					Если диапазон(ы) не найден(ы), то ed среагирует вопросиком, как на неправильную команду (забегая вперёд, скажу что sed действует по другому).
				</div><p>
			</p></div><div class="section" title="Где применяется sed."><div class="titlepage"><div><div><h4 class="title"><a name="id2509167"></a>Где применяется sed.</h4></div></div></div><p>
				Редактор ed конечно не самая удобная штука, но на оборудовании 70х ничего лучше придумать было нельзя. К счастью, прогресс не стоит на месте, и с развитием железа развивались и программы для него, в частности текстовые редакторы. Все вы прекрасно знаете, во что превратились сегодня текстовые редакторы - достаточно сказать, что даже самые опытные пользователи попросту не знают 80% возможностей своего любимого редактора! Однако, была и другая ветка развития текстовых редакторов: во многих случаях нет нужды каждый раз писать новые файлы с нуля, часто нужно просто исправлять какой-либо файл по известному алгоритму, это действие конечно можно произвести обычным редактором, но на самом деле, присутствие юзера тут не только не необходимо, но даже вредно! Юзерам свойственно постоянно ошибаться, всё путать да и вообще - юзер, ленивое и капризное существо: если ему было сказано: "сотри в файле %WINDOWS%\sysok.ini все слова hide", а юзер стёр не все, не hide, да и вообще не то(хорошо, если слова в файлах стирал, а не сами файлы), то этот самый юзер будет обвинять меня, вас, глючный компьютер, кривую программу, карму, да что угодно, но только не свою криворукость...
			</p><p>
				Имеется ещё 1000 и 7 разных применений, где участие юзера нужно если не исключить, то хотя-бы сильно ограничить: например огромный класс задач про безопасность, ну сколько раз можно повторять: "Читай логи!!!", дык пробовал, "ниасилил - многабукв". Правильно, что-бы юзер увидел опасность необходимо отфильтровать весь "мусор", компьютеру всё равно, он железный: было 10482 атаки на закрытую уязвимость, и одна успешная на открытую - в логе будет 10483 строки (в лучшем случае), и даже если юзер - терпеливая и прилежная блондинка, то даже тогда, она скорее сломает PageDown (сотрёт колесо мыши), прежде чем найдёт нужную строчку.
			</p><p>
				Ну по поводу фильтров можно возразить: дескать в том-же <span class="command"><strong>ed</strong></span> можно набрать <span class="command"><strong>g/re/p</strong></span>, что приведёт к фильтрации только нужных строк. Та-же функциональность присутствует во всех остальных текстовых редакторах (включая notepad), мало того, для этого и редактор не нужен, можно прямо в консоли набрать <span class="command"><strong>grep</strong></span> (ну вы поняли, почему эта команда так названа). Всё это так, но для фильтрации этого зачастую мало, лично мне по любому не осилить ни 10483 не фильтрованные, ни 2174 фильтрованные строки: до того, как я научился использовать sed, мне приходилось составлять зубодробительные конвейеры, а потом всё равно юзать less|PageDown|search, в разных комбинациях. Это не очень сложно, но отнимает массу времени.
			</p><p>
				В фильтрации, да и не только в ней, часто нужно реализовать очень простой алгоритм, который почему-то не реализован в различных имеющихся утилитах. Писать для этого программу на C лениво да и не быстро. Для таких случаев придуманы скриптовые языки программирования(ЯП), например bash, perl, awk, php, и многие другие. Все они имеют два недостатка:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Они универсальные, а значит тянут за собой множество ненужного функционала. Конечно, это удобно для кодера, но вот <span class="emphasis"><em>пользователю</em></span> это совсем не нужно. Ему надо просто решение, а не "самый крутой ЯП".
					</li><li class="listitem">
						Все эти ЯП жутко медленные, что связано и с п1, и с тем, что каждую команду нужно множество раз "парсить". Вот например bash'евское
						<pre class="programlisting">
#!/bin/bash

echo $VARIABLE
						</pre>
						Ага. На 10000 строк! Это-ж каждый раз надо прочитать из файла слово "echo", разобраться что оно значит, а потом найти нужную $VARIABLE... Такой скрипт будет выполнятся в сотни раз дольше чем сам вывод!
					</li></ol></div><p>
				Таким образом, нам необходим особый ЯП, который лишён этих недостатков. Таким языком как раз и является sed.
			</p></div><div class="section" title="Итог."><div class="titlepage"><div><div><h4 class="title"><a name="id2509408"></a>Итог.</h4></div></div></div>
			Компьютеры предназначены для обработки информации, она может представляются в разных видах, но нас интересует только то, что представлено в виде текста, рассмотрим задачи обработки текста в порядке увеличения сложности:
			<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Примитивные задачи.</p><p>С такими задачами справятся доступные утилиты, если нам нужно просто скопировать информацию, или скопировать несколько файлов в один, нам нужна <span class="command"><strong>cat</strong></span>, для резки файлов подойдёт <span class="command"><strong>split</strong></span> и <span class="command"><strong>cut</strong></span>, для поиска подстрок сгодится <span class="command"><strong>grep</strong></span>, и так далее.</p></li><li class="listitem"><p>Задачи, для которых не хватает инструментов из п1</p><p>А вот тут-то и пригодится sed.</p></li><li class="listitem"><p>Ещё более сложные задачи.</p><p>Если мощности sed не хватает, придётся писать собственный анализатор текста. При этом не стоит забывать про sed - можно сэкономить огромное количество времени (как своего, так и процессорного), если прогнать входные и/или выходные данные через sed-фильтр(ы).
					</p><p>
						</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
							Что делать, если мощности и/или возможностей возможностей sed не хватает? Следует выяснить <span class="emphasis"><em>почему</em></span> так. К примеру: ваша задача требует обработки текста, и ещё чего-то, что в sed не реализовано. У вас есть следующие варианты:
							<div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Использовать sed как входной фильтр. К примеру можно не просто посмотреть текст командой <span class="command"><strong>less</strong></span>, а посмотреть уже фильтрованный текст.
								</li><li class="listitem">
									Вы можете вызвать другую утилиту <span class="emphasis"><em>внутри</em></span> sed. Это очень мощный, и потому опасный приём. Далее приведены <a class="link" href="ch04s04.html#exa_crc">множество примеров</a> с использованием этой возможности.
								</li><li class="listitem">
									Вы можете выполнить sed внутри своего приложения. Впрочем, мне не кажется, что это - хорошая идея.
								</li><li class="listitem">
									И наконец, вы можете вообще отказаться от sed. Однако, я думаю, очень многие материалы этой книги будут вам полезны, во первых вы сможете быстро и просто протестировать регулярное выражение с помощью sed, а во вторых, речь у меня идёт именно о встроенных в GNU Linux выражениях, а не о каких-то других, которых у вас может и не оказаться под рукой. Вот <a class="link" href="ch02s04.html#bugs_utf">пример использования регулярных выражений в языке Си</a> (Правда там обсуждается проблема с UTF, но пример как раз и приведён здесь потому, что это проблема касается не только sed, но и всех остальных ЯП).
								</li></ol></div></div><p>
					</p></li><li class="listitem"><p>Недоступные для решения на компьютере задачи.</p><p>Да, есть и такие... Что-ж, вот тут-то и пригодятся обычные редакторы, например этот текст я набирал в <span class="command"><strong>kate</strong></span>. Однако, многие части у меня уже были готовые, потому я их прямо суда вставил, прогнав через sed конечно.</p></li></ol></div></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://forum.drbatty.ru/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch01s02.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Краткий учебник по sed. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Использование sed.</td></tr></table></div></body></html>
